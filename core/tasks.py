from celery.decorators import task
from celery.utils.log import get_task_logger
from celery import shared_task, task, chain
from subprocess import call, run, PIPE, Popen
from api.settings import BASE_DIR
from rest_framework.renderers import JSONRenderer
import os
import json
from .serializers import SetupSerializer, AnsiblePlaybookSerializer
from .models import Setup, AnsiblePlaybook
from tempfile import NamedTemporaryFile
from jinja2 import Template
from os.path import isfile

logger = get_task_logger(__name__)
env = os.environ

def generate_ssh_key(username, cloud, service, name):
    comment = "Autogenerated OpsClick API"
    priv_key_path = "/root/.ssh/{0}-{1}-{2}-{3}".format(username, cloud, service, name)
    command = ["/usr/bin/ssh-keygen", "-t", "rsa", "-N", "", "-f", priv_key_path, "-C", comment]

    try:
        if not isfile(priv_key_path):
            run(command)
    except:
        logger.warn("something wrong with ssh-keygen")

    return priv_key_path

def running_setup(data):
    chain = ansible_setup.s(data) | install_docker.s() | install_service.s(data['service'])
    res = chain()
    return res

@shared_task
def ansible_setup(data=None):
    if not data:
        return
    (service, cloud, options) = data['service'], data['cloud'], data['options']

    private_ssh_key = generate_ssh_key("test", cloud, service, "test1")
    key_file = open(private_ssh_key + ".pub", "r")
    ssh_key = key_file.readline().strip('\n')
    key_file.close()
    data['options']['ssh_pub_keys'].append({ 'name': "OpsClick API Deploy",
                                             'key': ssh_key })

    cloud_path = "{0}/clouds/{1}".format(BASE_DIR, cloud)
    cloud_playbook = cloud_path + "/main.yml"
    cloud_host = cloud_path + "/hosts"
    logger.debug("%s" % options)

    if service and cloud:
        logger.debug("configuring the cloud %s" % (cloud))
        command = ['ansible-playbook', cloud_playbook, '-i', cloud_host, '--extra-vars', str(options)] 
        logger.debug(" ".join(command))

        env['ANSIBLE_CONFIG'] = cloud_path + "/ansible.cfg"
        ansible_call = Popen(command, stdout=PIPE, env=env)
        try:
            output, errs = ansible_call.communicate()
        except:
            logger.warn("something wrong with the ansible call")
            return

        outfile = open("/tmp/output.ansible", "w")
        outfile.write(output.decode("utf-8"))
        outfile.close()

        try:
            outs  = json.loads(output.decode("utf-8"))
        except:
            logger.warn("something wrong with json decode")
            return

        pb_serializer = AnsiblePlaybookSerializer(data=outs)

        if pb_serializer.is_valid():
            pb_instance = pb_serializer.save()
            data['playbook'] = pb_instance.id

            setup = Setup(service=service,
                          cloud=cloud,
                          options=options,
                          playbook=data['playbook'])
            setup.save()

            code = """
        function() {
            var droplets_ip = []
            db[collection].find(query).forEach(function(doc) {
                doc.plays.forEach(function(play) {
                    play.tasks.forEach(function(task) {
                        if(task.hosts.localhost.results) {
                            task.hosts.localhost.results.forEach(function(result) {
                                if(result.droplet) {
                                    droplets_ip.push(result.droplet.ip_address);
                                }
                            });
                        }
                    });
                });
            });
            if(droplets_ip.length > 0){
                return droplets_ip;
            } 
            return false;
        }
        """
        ip_address = AnsiblePlaybook.objects.filter(id=pb_instance.id,).exec_js(code)

        return (private_ssh_key, ip_address)
    else:
        logger.warn("We need to know the service and the cloud")

@shared_task
def install_service(info, service, conf_vars={}):
    private_ssh_key, hosts = info
    service_path = "{0}/services/{1}".format(BASE_DIR, service)
    service_playbook = service_path + "/main.yml"

    env['ANSIBLE_CONFIG'] = service_path + "/ansible.cfg"
    command = ['ansible-playbook', service_playbook, '-i', hosts, "--private-key", private_ssh_key, "--extra-vars", str(conf_vars)]
    ansible_call = Popen(command, stdout=PIPE, env=env)

    logger.info(command)
    try:
        output, errs = ansible_call.communicate()
    except:
        print("Unexpected error:", sys.exc_info()[0])
        logger.warn("something wrong with ansible install service call")
        raise

    outfile = open("/tmp/output.service", "w")
    outfile.write(output.decode("utf-8"))
    outfile.close()

    if ansible_call.returncode == 0:
        return True
    return False

@shared_task
def install_docker(info):
    private_ssh_key, hosts = info
    if not hosts:
        logger.info("You need to define the hosts")
        return

    docker_path = "{0}/clouds/lib/{1}".format(BASE_DIR, "docker")
    docker_playbook = docker_path + "/main.yml"
    inventory = """
    [targets]
    {% for host in hosts %}
    {{ host }}
    {% endfor %}
    """
    inventory_template = Template(inventory)
    rendered_inventory = inventory_template.render({'hosts': hosts})

    hosts = NamedTemporaryFile(delete=False)
    hosts.write(rendered_inventory.encode("utf-8"))
    hosts.close()

    env['ANSIBLE_CONFIG'] = docker_path + "/ansible.cfg"
    command = ['ansible-playbook', docker_playbook, '-i', hosts.name, "--private-key", private_ssh_key]
    ansible_call = Popen(command, stdout=PIPE, env=env)

    logger.info(command)
    try:
        output, errs = ansible_call.communicate()
    except:
        print("Unexpected error:", sys.exc_info()[0])
        logger.warn("something wrong with ansible install docker call")
        raise

    outfile = open("/tmp/output.docker", "w")
    outfile.write(output.decode("utf-8"))
    outfile.close()

    if ansible_call.returncode == 0:
        logger.info("docker was installed")

    return private_ssh_key, hosts.name

